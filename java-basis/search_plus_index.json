{"./":{"url":"./","title":"前言","keywords":"","body":"Introduction "},"chapter1/":{"url":"chapter1/","title":"java 基本数据类型","keywords":"","body":"Introduction "},"chapter1/section.1.html":{"url":"chapter1/section.1.html","title":"八大基础数据类型","keywords":"","body":"八大基础数据类型 》 java一共有8个基本数据类型 数据类型 存储需求 取值范围 前/后缀 int 4字节 -2^32~ 2^32-1 short 2字节 -2^16~ 2^16 -1 long 8字节 -2^64~2^64 -1 后缀：L或l,如40000L byte 1字节 -2^8 ~ 2^8 -1 float 4字节 后缀F或f double 8字节 默认，后缀可以是D或d char 1个字符 \\u0000~\\Uffff boolean true/false 》 JAVA范围与j运行ava代码机器无关,因为Java程序必须保证在所有机器上都能够得到相同的结果，所以各种数据类型的取值范围必须固定。 》 浮点类型的特殊常量 特殊值 对应常量 正无穷大 Double.POSITIVE_INFINITY 、 Float.POSITIVE_INFINITY 负无穷大 Double.NEGATIVE_INFINITY、Float.NEGATIVE_INFINITY NaN(不是一个数) Double.NaN、Float.NaN 》 浮点类型不适用于无法接受舍入误差的金融计算中，如2.0 -1.1 会输出0.8999999999999999，而不是0.9》》 原因：浮点数值采用二进制系统表示法（二进制无法精确表示分数1/10）》》 如果不允许输入误差，需要使用 BigDecimal类 "},"chapter1/section.2.html":{"url":"chapter1/section.2.html","title":"数值类型转换","keywords":"","body":"数值类型转换 》 分为自动类型转换和强制类型转换。 自动类型转换 》 满足以下条件将自动转换 这2种类型是兼容的。 目的类型数的范围比来源类型的大。 》 当以上2个条件都满足时,拓宽转换(widening conversion)发生》 数字类型和字符类型(char)或布尔类型(bollean)是不兼容的。字符类型(char)和布尔类型(bollean)也是互相不兼容的。 》 虚线表示数据可能丢失,如果对图中箭头反向转换，会报错，需要强制转换 强制转换 (target-type)value 》 截断(truncation):把浮点值赋给整数类型时一种不同的类型转换,小数部分会被舍去。 》 java 257强制转换赋值给byte会怎么样？323呢?》》 答：byte范围是256,所以257赋值后，值为1(257/256)。323为67(323/256) "},"chapter1/section.3.html":{"url":"chapter1/section.3.html","title":"表达式中的类型提升","keywords":"","body":"表达式中的类型提升 》 所有byte型和short型的值在表达式中会被提升到int类型 好处：避免了计算过程中中间结果超出范围 缺点，需要强转 》 类型提升规则： 如果两个操作数中有一个是 double 类型， 另一个操作数就会转换为 double 类型。 否则， 如果其中一个操作数是 float 类型， 另一个操作数将会转换为 float 类型。 否则， 如果其中一个操作数是 long 类型， 另一个操作数将会转换为 long 类型。 否则， 两个操作数都将被转换为 int 类型 byte a = 50; byte b = 20; int i = b * a; //ok b = b * 2;//error,b * 2 会提升到int,b 是一个byte b = (byte)b; //ok "},"chapter1/section.4.html":{"url":"chapter1/section.4.html","title":"对象包装器和自动装箱","keywords":"","body":"对象包装器和自动装箱 "},"chapter2/":{"url":"chapter2/","title":"数组","keywords":"","body":"数组 "},"chapter2/section.1.html":{"url":"chapter2/section.1.html","title":"数组初始化","keywords":"","body":"数组初始化 "},"chapter2/section.2.html":{"url":"chapter2/section.2.html","title":"初始化匿名数组","keywords":"","body":"初始化匿名数组 "},"chapter2/section.3.html":{"url":"chapter2/section.3.html","title":"多维数组","keywords":"","body":"多维数组 "},"chapter2/section.4.html":{"url":"chapter2/section.4.html","title":"对象包装器和自动装箱","keywords":"","body":"对象包装器和自动装箱 "},"chapter3/":{"url":"chapter3/","title":"运算符","keywords":"","body":"运算符 "},"chapter4/":{"url":"chapter4/","title":"流程控制语句","keywords":"","body":"流程控制语句 "},"chapter4/section.1.html":{"url":"chapter4/section.1.html","title":"选择语句","keywords":"","body":"选择语句 "},"chapter4/section.2.html":{"url":"chapter4/section.2.html","title":"循环语句","keywords":"","body":"循环语句 "},"chapter4/section.3.html":{"url":"chapter4/section.3.html","title":"跳转语句","keywords":"","body":"跳转语句 "},"chapter5/":{"url":"chapter5/","title":"对象与类","keywords":"","body":"对象与类 "},"chapter5/section.1.html":{"url":"chapter5/section.1.html","title":"类的组成","keywords":"","body":"类的组成 "},"chapter5/section.2.html":{"url":"chapter5/section.2.html","title":"类的参数传递","keywords":"","body":"类的参数传递 "},"chapter5/section.3.html":{"url":"chapter5/section.3.html","title":"类之间的关系","keywords":"","body":"类之间的关系 "},"chapter5/section.4.html":{"url":"chapter5/section.4.html","title":"嵌套类和内部类","keywords":"","body":"嵌套类和内部类 "},"chapter5/section.5.html":{"url":"chapter5/section.5.html","title":"抽象类","keywords":"","body":"抽象类 "},"chapter5/section.6.html":{"url":"chapter5/section.6.html","title":"枚举类","keywords":"","body":"枚举类 "},"chapter6/":{"url":"chapter6/","title":"字符串","keywords":"","body":"字符串 "},"chapter6/section.1.html":{"url":"chapter6/section.1.html","title":"字符串的构造函数","keywords":"","body":"字符串的构造函数 "},"chapter6/section.2.html":{"url":"chapter6/section.2.html","title":"字符串操作","keywords":"","body":"字符串操作 "},"chapter6/section.3.html":{"url":"chapter6/section.3.html","title":"利用valueOf( )实现数据转换","keywords":"","body":"利用valueOf( )实现数据转换 "},"chapter6/section.4.html":{"url":"chapter6/section.4.html","title":"StringBuffer","keywords":"","body":"StringBuffer "},"chapter7/":{"url":"chapter7/","title":"继承","keywords":"","body":"继承 "},"chapter7/section.1.html":{"url":"chapter7/section.1.html","title":"成员的访问与继承","keywords":"","body":"成员的访问与继承 "},"chapter7/section.2.html":{"url":"chapter7/section.2.html","title":"super","keywords":"","body":"super "},"chapter7/section.3.html":{"url":"chapter7/section.3.html","title":"方法重写(override)","keywords":"","body":"方法重写(override) "},"chapter7/section.4.html":{"url":"chapter7/section.4.html","title":"子类构造器","keywords":"","body":"子类构造器 "}}